\documentclass[a4paper,11pt]{article}

\usepackage[T1]{fontenc}
\usepackage[swedish]{babel} 
\usepackage[utf8]{inputenc}

\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead{}
\fancyfoot{}

\fancyhead[L]{Miniduke}
\fancyhead[R]{pbos@kth.se}
\fancyfoot[C]{Compiler Construction - DD2488}
\fancyfoot[R]{\thepage}

\usepackage{fancyvrb}
\usepackage{listings}
\lstset{language=C,
	basicstyle=\footnotesize,
	numbers=left,
	numberstyle=\footnotesize,
	title=\lstname,
	showstringspaces=false,
	fancyvrb=true,
	extendedchars=true,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4}

\lstset{ % För att å, ä och ö ska funka inuti lstlistings, kan behövas för andra symboler också..
	literate={ö}{{\"o}}1
		{ä}{{\"a}}1
		{å}{{\aa}}1
	}

\title{Miniduke -- MiniJava compiler}
\author{Peter Boström -- \emph{pbos@kth.se}}

\begin{document}
\maketitle
\pagestyle{fancyplain}

\section*{Introduction}

{\tt miniduke} is a compiler for MiniJava defined by Appel, but with some minor
changes introduced by the compiler-construction course followed.

{\tt miniduke} is written in C and uses the lexical-analyzer generator flex and the
parser generator GNU bison (aka Bison). Compared to other java-based compilers
used in the course, {\tt miniduke}

\subsection*{Building}

Building {\tt miniduke} requires {\tt flex} and {\tt bison} to be installed
(apart from gcc). Running {\tt make} generates intermediate files from flex
and Bison and finally compiles them with gcc into {\tt miniduke}.

\subsection*{Invocation}

Running {\tt miniduke} can be done as follows:

{\tt miniduke [file.java]}

Use flags {\tt -o dir} to change output directory and {\tt -S} to only generate
the final assembly.

For Tigris-submission purposes {\tt miniduke} reads and ignores the argument
{\tt JVM}.

\section*{Tests}

Apart from other students' tests, tests were written simultaneously during
{\tt miniduke}'s development. When writing code checking that the main method
is called main, it's nice to write a corresponding test case which confirms
its validity.

\section*{Lexical Analysis}

flex is used to generate a lexical analyzer which feeds parsed tokens into the
parser generated by Bison. Comments, multiline comments, spaces, newlines etc.
which do not affect the code whatsoever are simply skipped and never fed into
the parser.

Keywords, such as {\tt if}, or even less obvious MiniJava tokens such as {\tt
System.out.println} are fed into the parsers as single tokens. It's important
to note that \emph{main} is not parsed as a single token, but rather as an
identifier. This is because in contexts where \emph{main} does not identify
the main method of a program it needs to be parsed as an identifier. Thus the
job of rejecting main methods not called main requires an additional check
manually performed by the parser.

The lexer parses the entire file and feeds it to the parser token-per-token.

\section*{Parsing}

The parse step uses a bison-generated parser from a grammar file similar to the
course grammar. Some additional intermediate rules are added to be able to
express the language (expressions such as Var* become VarList, as Bison doesn't
support repetition). One intermediate rule is added to catch the creation of
multidimensional arrays which are not supported in MiniJava. Otherwise the
parser would interpret {\tt new int[3][2]} as {\tt (new int[3])[2]} which
differs from Java behavior.

This generated parser generates an Abstract Syntax Tree (AST) directly, and no
CST is ever built. This method avoids the extra code needed to transform a CST
into an AST. For each node generated by the parser, a linenumber from the lexer
is stored. This is to be able to identify error locations later. For instance,
during typecheck, the code piece {\tt int i; i = true; } would be rejected,
but without approximate line numbers for the {\tt i = true;} statement node,
debugging the program could be way more hard.

If the parser recieves a token which doesn't match the language, it generates
an error.

\section*{Semantic Analysis}

\subsection*{Symtab}

Simply traverses the AST and generates a symbol table. The program symtab
contains a mainclass and optionally other classes (depending on the program).
Each class contains fields and methods. Methods contain parameters and local
variable declarations.

\subsection*{Typecheck}

Binds identifiers to symtab methods, classes, fields, parameters or locals to
their symtab respectives. During this step, duplicate declarations or locals
with the same name as other parameters etc. throw errors with linenumbers.

Binding identifiers to their respective symtab equivalents means that any
subsequent lookups can be done really quickly (in constant time).

\subsection*{AST Binding}

During ``ast binding'', all expression nodes are assigned a type. Leaf nodes
such as method calls, constants, identifiers etc. are assigned their
corresponding type. If the types of operands are valid for an operation (say
{\tt <} with operands as {\tt int}), and the operation's expression node is
assigned its corresponding type (our example {\tt <} always yields a {\tt
boolean} result).

Any incorrect assignments or operations are caught in this step. Code may of
course still have bugs (such as stack overflows etc. or uninitialized variables
which is not checked by our compiler).

\section*{Jasmin}

Finally it's time to output Jasmin assembly. Jasmin is an assembler for the
Java Virtual Machine. Any code reaching this step will compile, as no errors
are thrown during Jasmin generation (last checks are performed during AST
binding).

As Jasmin (and the JVM) is stack-based, code is easily generated by parsing the
AST depth first. Each expression is responsible for putting its corresponding
value on the top of the stack. This means that the code (a) < (b) is generated
as follows: put code for generating (a), put code for generating (b), then
a compare instruction with corresponding jump takes the two top values, which
are the return values from (a) and (b) and jump corrispondingly. Its jump-to
labels have codes for putting a boolean true-or-false value on the stack
respectively.

For simplicity's sake {\tt miniduke} generates a boolean on the stack for each
boolean expression ({\tt if(a < 3)} doesn't have to generate a boolean value,
you can simply jump to the corresponding block or else-block depending on the
condition). Always generating a boolean value on the stack means that {\tt
miniduke} can handle if-cases and assigning boolean expressions uniformly. if-
cases take a boolean from the top of the stack and jump depending on its
value, while assignments simply takes the top value from the stack and stores
it.

It's important to note that Jasmin can have issues with instructions appearing
as different kinds of variable names. So any method-, field- or class name
needs to be escaped properly (surrounded with '). {\tt getfield goto/goto I}
doesn't work, while {\tt getfield 'goto/goto' I} does.

\section*{Results}

{\tt miniduke} turned out to be a very quick compiler. All test cases compiled
in Tigris in a few seconds at most. This compared to other implementations done
in Java which took 15-30 minutes. Even if the comparison isn't really fair
(with a lot of this being startup time for the JVM, but still it's a nice
boast.

It's considerably (way-way) faster than {\tt javac} or compiling a short C
program in {\tt gcc}, though that comparison isn't really fair, as any
commercial-grade compiler will perform a lot more analysis and generate way
more efficient code in a lot of cases, but it was nice to have the programs
compile almost instantly. Most of the time spent running the tests was either
on execution or assembling the Jasmin source, and not compiling the actual
source code.

\end{document}

